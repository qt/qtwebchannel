/****************************************************************************
**
** Copyright (C) 2014 Klar√§lvdalens Datakonsult AB, a KDAB Group company, info@kdab.com, author Milian Wolff <milian.wolff@kdab.com>
** Contact: http://www.qt-project.org/legal
**
** This file is part of the documentation of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Digia.  For licensing terms and
** conditions see http://qt.digia.com/licensing.  For further information
** use the contact form at http://qt.digia.com/contact-us.
**
** GNU Free Documentation License Usage
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file.  Please review the following information to ensure
** the GNU Free Documentation License version 1.3 requirements
** will be met: http://www.gnu.org/copyleft/fdl.html.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
    \title Qt WebChannel JavaScript API
    \page qtwebchannel-javascript.html

    \brief This page explains how to use the JavaScript QWebChannel API in HTML clients.

    \chapter Setup

    To communicate with a QWebChannel or WebChannel, any HTML client must use and setup the
    JavaScript API provided by \c qwebchannel.js. For HTML clients run inside QtWebKit, you
    can load the file via \c qrc:///qwebchannel/qwebchannel.js. For external clients you will
    need to copy the file to your webserver. Then instantiate a QWebChannel object and pass
    it the message passing interface and a callback function.

    The message passing interface depends on the what interface you configured your WebChannel
    on the QML/C++ side to use. Currently, only communication via a \c WebSocket or \c navigator.qt
    is supported.

    \section1 WebSocket

    If you are using a WebSocket server, then pass the URL to connect
    to the server to the JavaScript QWebChannel as shown in the \l{Standalone Example}:

    \code
<script type="text/javascript">
    //BEGIN SETUP
    var baseUrl = (/[?&]webChannelBaseUrl=([A-Za-z0-9\-:/\.]+)/.exec(location.search)[1]);
    new QWebChannel(baseUrl, function(channel) {
        // channel is initialized, now you can access all published objects via their identifier.
    });
    //END SETUP
</script>
    \endcode

    \section1 \c navigator.qt

    Alternatively, if you use a QML WebView, you can use the \c navigator.qt object for a more
    efficient message passing, see also the \l{QML Example}:

    \code
<script type="text/javascript">
//BEGIN SETUP
new QWebChannel(navigator.qt, function(channel) {
    // channel is initialized, now you can access all published objects via their identifier.
});
//END SETUP
</script>
    \endcode

    Remember that on the QML side, you will also have to enable this functionality:

    \code
WebView {
    experimental.preferences.navigatorQtObjectEnabled: true
}
    \endcode

    \chapter Interacting with QObjects

    Once the callback passed to the QWebChannel object is invoked, the channel has finished
    initialization and all published objects are accessible globally to the HTML client. Thus,
    assuming an object was published with the identifier "foo", then we can interact with it
    as shown in the example below. Note that all communication between the HTML client and
    the QML/C++ server is asynchronous. Properties are cached on the HTML side. Furthermore
    keep in mind that only QML/C++ data types which can be converted to JSON will be (de-)serialized
    properly and thus accessible to HTML clients.

    \code
new QWebChannel(navigator.qt, function(channel) {
    // connecting to a signal
    foo.mySignal.connect(function() {
        // this callback will be invoked whenever the signal is emitted on the C++/QML side.
        console.log(arguments);
    });

    // invoking a method
    foo.myMethod(arg1, arg2, function(returnValue) {
        // this callback will be invoked when myMethod has a return value. Keep in mind that
        // the communication is asynchronous, hence the need for this callback.
        console.log(returnValue);
    });

    // reading a property's currently cached value
    console.log(foo.myProperty);
    // writing a property
    foo.myProperty = "Hello World!";
    // getting notified about a property change
    foo.onMyPropertyChanged.connect(function(newValue) {
        console.log(newValue);
    });

    // Q_ENUM support
    console.log(foo.MyEnum.MyEnumerator);
});
    \endcode
*/
